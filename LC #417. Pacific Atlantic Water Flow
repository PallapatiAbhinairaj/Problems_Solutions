https://leetcode.com/problems/pacific-atlantic-water-flow/


SOLUTION:

class Solution {
public:
    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {
        int m = heights.size() , n = heights[0].size();

        vector<vector<bool>> pacific(m , vector<bool>(n , false));
        vector<vector<bool>> atlantic(m , vector<bool>(n , false));

        function<void(int,int,vector<vector<bool>>&)> dfs = [&](int r, int c, vector<vector<bool>>& visited) {
            visited[r][c] = true;
            int dirs[4][2] = {{1,0} , {-1,0} , {0,1} , {0,-1}};
            for(auto &d : dirs) {
                int nr = r + d[0] , nc = c + d[1];
                if(nr < 0 || nc < 0 || nr >= m || nc >= n) continue;
                if(visited[nr][nc]) continue;
                if(heights[nr][nc] < heights[r][c]) continue;
                dfs(nr , nc , visited);
            }  
        };

        //pacfic border
        for(int i = 0 ; i < m ; i++) dfs(i , 0 , pacific);              // 0 because , we are starting from first na 
        for(int j = 0 ; j < n ; j++) dfs(0 , j , pacific);


        //atlantic
        for(int i = 0 ; i < m ; i++) dfs(i , n-1 , atlantic);          //n-1 because we are starting from below na
        for(int j = 0 ; j < n ; j++) dfs(m-1 , j , atlantic);

        //result
        vector<vector<int>> result;
        for(int i = 0 ; i < m ; i++)
        {
            for(int j = 0 ; j < n ; j++)
            {
                if(pacific[i][j] && atlantic[i][j])
                {
                    result.push_back({i,j});
                }
            }
        }

        return result;
    }
};

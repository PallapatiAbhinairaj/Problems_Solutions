link : https://leetcode.com/problems/partition-equal-subset-sum/submissions/1779066175/

class Solution {
public:

    bool subsetSumToK(int n , int k , vector<int> &arr) { 
        vector<vector<bool>> dp(n , vector<bool>(k+1 , 0));

        dp[0][0] = true;
        if (arr[0] <= k) dp[0][arr[0]] = true;

        for(int ind = 1 ; ind < n ; ind++) 
        {
            dp[ind][0] = true;
            //dp[0][arr[0]] = true;
            for(int target = 1 ; target <= k ; target++)
            {
                bool notTake = dp[ind - 1][target];
                bool take = false;
                if(arr[ind] <= target)
                {
                    take = dp[ind - 1][target - arr[ind]];
                }
                
                dp[ind][target] = take || notTake;
                
            }
        }
        
        return dp[n-1][k];
    }




    bool canPartition(vector<int>& nums) {

        int totSum = 0;
        int n = nums.size();
        for(int i = 0 ; i < n ; i++) totSum += nums[i];
        if(totSum % 2) return false;
        int target = totSum / 2;

        return subsetSumToK(n , target , nums);
        
    }
};








another soltion : using dp tabular : index shifting 

class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {


        int n = text1.size();
        int m = text2.size();

        vector<vector<int>> dp(n+1 , vector<int>(m+1 , 0));
        for(int j = 1 ; j <= m ; j++) dp[0][j] = 0;
        for(int i = 1 ; i <= n ; i++) dp[i][0] = 0;
        for(int i = 1 ; i <= n ; i++)
        {
            for(int j = 1 ;j <= m ; j++)
            {
                if(text1[i-1] == text2[j-1]) dp[i][j] = 1 + dp[i-1][j-1];
                else dp[i][j] = max(dp[i-1][j] , dp[i][j-1]);
            }
        
        }

            return dp[n][m];
}
};
